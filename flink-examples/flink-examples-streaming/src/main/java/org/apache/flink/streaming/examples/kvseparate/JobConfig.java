package org.apache.flink.streaming.examples.kvseparate;

import org.apache.flink.api.java.utils.ParameterTool;
import org.apache.flink.configuration.ConfigOption;
import org.apache.flink.configuration.ConfigOptions;
import org.apache.flink.configuration.Configuration;
import org.apache.flink.contrib.streaming.state.DefaultConfigurableOptionsFactory;
import org.apache.flink.contrib.streaming.state.RocksDBStateBackend;
import org.apache.flink.runtime.state.StateBackend;
import org.apache.flink.runtime.state.filesystem.FsStateBackend;
import org.apache.flink.runtime.state.memory.MemoryStateBackend;
import org.apache.flink.streaming.api.CheckpointingMode;
import org.apache.flink.streaming.api.environment.CheckpointConfig;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;

import org.rocksdb.ColumnFamilyOptions;
import org.rocksdb.CompressionType;
import org.rocksdb.DBOptions;
import org.rocksdb.Statistics;
import org.rocksdb.StatsLevel;

import java.io.IOException;
import java.util.Collection;

import static org.apache.flink.streaming.examples.kvseparate.source.GenerateSource.ValueLengthDistribution.UNIFORM;

/**
 * Configurations for the job.
 */
public class JobConfig {

    public static final ConfigOption<String> JOB_NAME = ConfigOptions
            .key("jobName")
            .stringType()
            .defaultValue("kv-separate-bench")
            .withDescription("Job name");

    public static final ConfigOption<Integer> PARALLELISM = ConfigOptions
            .key("parallelism")
            .intType()
            .defaultValue(1)
            .withDescription("the parallelism of the job");

    // word source options ======================================

    public static final ConfigOption<Integer> SOURCE_PARALLELISM = ConfigOptions
            .key("sourceParallelism")
            .intType()
            .defaultValue(1)
            .withDescription("the parallelism of the source");

    public static final ConfigOption<Integer> KEY_NUMBER = ConfigOptions
            .key("keyNumber")
            .intType()
            .defaultValue(100000)
            .withDescription("Number of different keys which will influence state size.");

    public static final ConfigOption<Integer> KEY_LENGTH = ConfigOptions
            .key("keyLength")
            .intType()
            .defaultValue(16)
            .withDescription("Length of key which will influence state size.");

    public static final ConfigOption<Integer> KEY_RATE = ConfigOptions
            .key("keyRate")
            .intType()
            .defaultValue(1000000)
            .withDescription("Rate to emit keys");

    public static final ConfigOption<Double> KEY_HIT_RATIO = ConfigOptions
            .key("keyHitRatio")
            .doubleType()
            .defaultValue(0.1D)
            .withDescription("The hit ratio of key in kv-separate mode.");

    public static final ConfigOption<String> SOURCE_VALUE_LENGTH_DISTRIBUTION = ConfigOptions
            .key("valueLengthDistribution")
            .stringType()
            .defaultValue(UNIFORM.name())
            .withDescription("The value length distribution generated by source.");

    public static final ConfigOption<Integer> VALUE_AVG_LENGTH = ConfigOptions
            .key("valueStringAvgLength")
            .intType()
            .defaultValue(500)
            .withDescription("The average length of generated value string data.");

    public static final ConfigOption<Integer> VALUE_LENGTH_STANDARD_DEVIATION = ConfigOptions
            .key("valueLengthStandardDeviation")
            .intType()
            .noDefaultValue()
            .withDescription("The standard deviation of value length when the GenerateSource enable the " +
                    "GAUSSIAN_DISTRIBUTION mode. The default deviation equals to (0.2 * valueStringAvgLength).");

    public static final ConfigOption<Long> VALUE_LENGTH_CHANGE_PERIODIC = ConfigOptions
            .key("valueLengthChangePeriodic")
            .longType()
            .defaultValue(60 * 60 * 1000L)
            .withDescription("The periodic of value length changed for source generator.");

    //  checkpoint options ========================================

    public static final ConfigOption<Long> CHECKPOINT_INTERVAL = ConfigOptions
            .key("checkpointInterval")
            .longType()
            .noDefaultValue()
            .withDescription("Checkpoint interval in milliseconds, and default is Long.MAX_VALUE which" +
                    "means checkpoint is disable.");

    public static final ConfigOption<Long> CHECKPOINT_TIMEOUT = ConfigOptions
            .key("checkpointTimeout")
            .longType()
            .defaultValue(CheckpointConfig.DEFAULT_TIMEOUT)
            .withDescription("The timeout of checkpoint in milliseconds, and default is CheckpointConfig.DEFAULT_TIMEOUT (10min).");

    public static final ConfigOption<String> CHECKPOINT_PATH = ConfigOptions
            .key("checkpointPath")
            .stringType()
            .defaultValue("file:///tmp/")
            .withDescription("Checkpoint path");

    public static final ConfigOption<String> CHECKPOINT_MODE = ConfigOptions
            .key("checkpointMode")
            .stringType()
            .defaultValue("EXACTLY_ONCE")
            .withDescription("Checkpoint mode which is EXACTLY_ONCE or AT_LEAST_ONCE.");


    // state backend options ======================================

    public static final ConfigOption<String> STATE_BACKEND = ConfigOptions
            .key("stateBackend")
            .stringType()
//            .noDefaultValue()
            .defaultValue("ROCKSDB")
            .withDescription("Type of state backend, support memory, fs, gemini, niagara, rocksdb");

    public static final ConfigOption<String> ROCKSDB_COMPRESS = ConfigOptions
            .key("rocksdbCompress")
            .stringType()
            .defaultValue(CompressionType.SNAPPY_COMPRESSION.name())
            .withDescription("Compression type for rocksdb.");

    public static final ConfigOption<Boolean> ROCKSDB_STATS = ConfigOptions
            .key("rocksdbStats")
            .booleanType()
            .defaultValue(false);

    public static final ConfigOption<Boolean> SHARING_GROUP = ConfigOptions
            .key("sharingGroup")
            .booleanType()
            .defaultValue(false)
            .withDescription("Whether to enable sharing group");

    public static Configuration getConfiguration(ParameterTool params) {
        Configuration configuration = new Configuration();
        configuration.addAll(params.getConfiguration());

        return configuration;
    }

    public enum StateBackendType {
        MEMORY, FS, GEMINI, ROCKSDB
    }

    public static void configureCheckpoint(StreamExecutionEnvironment env, Configuration configuration) {
        if (configuration.get(CHECKPOINT_INTERVAL) == null) {
            return;
        }

        env.enableCheckpointing(configuration.getLong(CHECKPOINT_INTERVAL), CheckpointingMode.EXACTLY_ONCE);
        env.getCheckpointConfig().enableExternalizedCheckpoints(
                CheckpointConfig.ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION);
    }

    public static void setStateBackend(StreamExecutionEnvironment env, Configuration configuration) throws IOException {

        if (configuration.getString(STATE_BACKEND) == null) {
            return;
        }

        StateBackendType stateBackendType =
                StateBackendType.valueOf(configuration.getString(STATE_BACKEND).toUpperCase());

        String checkpointPath = configuration.getString(CHECKPOINT_PATH);
        StateBackend stateBackend;
        switch (stateBackendType) {
            case FS:
                stateBackend = new FsStateBackend(checkpointPath);
                break;
            case ROCKSDB:
                RocksDBStateBackend rocksdbStateBackend = new RocksDBStateBackend(checkpointPath, true);
                rocksdbStateBackend.setRocksDBOptions(new DefaultConfigurableOptionsFactory() {
                    @Override
                    public DBOptions createDBOptions(DBOptions dbOptions, Collection<AutoCloseable> collection) {
                        super.createDBOptions(dbOptions, collection);

                        if (configuration.getBoolean(ROCKSDB_STATS)) {
                            Statistics statistics = new Statistics();
                            statistics.setStatsLevel(StatsLevel.EXCEPT_DETAILED_TIMERS);
                            dbOptions.setStatistics(statistics);
                        }
                        dbOptions.setStatsDumpPeriodSec(300);
                        dbOptions.setAllowConcurrentMemtableWrite(false);
                        return dbOptions;
                    }

                    @Override
                    public ColumnFamilyOptions createColumnOptions(ColumnFamilyOptions currentOptions, Collection<AutoCloseable> collection) {
                        super.createColumnOptions(currentOptions, collection);

                        CompressionType compressionType =
                                CompressionType.valueOf(configuration.getString(ROCKSDB_COMPRESS).toUpperCase());
                        currentOptions.setCompressionType(compressionType);
                        return currentOptions;
                    }
                });
                stateBackend = rocksdbStateBackend;
                break;
            case MEMORY:
            default:
                stateBackend = new MemoryStateBackend();
        }

        env.setStateBackend(stateBackend);
    }
}
